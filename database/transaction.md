# 数据库事务transaction
数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 

## 四大特性
事务具有4个基本特征ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

### 原子性（Atomicity）
事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

### 一致性（Consistency）
事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。

```<sup>[2]</sup>
事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性：

强一致性：读操作可以立即读到提交的更新操作。
弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。
最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。
其他一致性变体还有：
单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。
会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。
```

### 隔离性（Isolation）
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

#### 并发问题
##### 1. 脏读
脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

例如，事务A修改了一个数据，但未提交；事务B读到了事务A未提交的更新结果；如果事务A提交失败，事务B读到的就是脏数据。
##### 2. 不可重复读
不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，因为在查询间隔内数据被另一个事务修改并提交了。

比如，例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。

不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是一次事务内分别读取到了另一事务执行前后的数据。
##### 3. 幻读
事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数），幻读执行的是插入和删除。

#### 隔离级别
1. Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
2. Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
3. Read committed (读已提交)：可避免脏读的发生。
4. Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

| 隔离级别 | 脏读 | 丢失更新 | 不可重复读 | 幻读 | 并发模型 | 更新冲突检测 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 未提交读：Read Uncommited	| √	| √	| √	| √	| 悲观	| x |
| 已提交读：Read commited	| x	| √	| √	| √	| 悲观	| x |
| 可重复读：Repeatable Read	| x	| x	| x	| √	| 悲观	| x |
| 可串行读：Serializable	| x	| x	| x	| × | 悲观	| x |


### 持久性（Durability）
持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

## 参考
- [1] [数据库事务的四大特性以及事务的隔离级别](https://www.cnblogs.com/fjdingsd/p/5273008.html)
- [2] [浅谈数据库事务](https://blog.csdn.net/u013007900/article/details/77927723)