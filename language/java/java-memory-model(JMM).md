# JAVA内存模型
## 什么是内存模型
给定一个程序和该程序的一串执行轨迹，内存模型描述了该执行轨迹是否是该程序的依次合法执行。对于Java，内存模型检查执行轨迹中的每次读操作，然后根据特定规则，检验该读操作观察到的写是否合法。

内存模型的一个高级的、非正式的概述显示其是一组规则，规定了线程的一个写操作何时会对另一个线程可见。

Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。

线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

而 JMM 就作用于工作内存和主存之间数据同步过程。它规定了如何做数据同步以及什么时候做数据同步。

## Java 内存模型的实现

了解 Java 多线程的朋友都知道，在 Java 中提供了一系列和并发处理相关的关键字，比如 Volatile、Synchronized、Final、Concurrent 包等。

其实这些就是 Java 内存模型封装了底层的实现后提供给程序员使用的一些关键字。

在开发多线程的代码的时候，我们可以直接使用 Synchronized 等关键字来控制并发，这样就不需要关心底层的编译器优化、缓存一致性等问题。

所以，Java 内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。

我们前面提到，并发编程要解决原子性、有序性和一致性的问题。下面我们就再来看下，在 Java 中，分别使用什么方式来保证。

### 原子性

在 Java 中，为了保证原子性，提供了两个高级的字节码指令 Monitorenter 和 Monitorexit。

在 Synchronized 的实现原理文章中，介绍过，这两个字节码，在 Java 中对应的关键字就是 Synchronized。

因此，在 Java 中可以使用 Synchronized 来保证方法和代码块内的操作是原子性的。

### 可见性

Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。

Java 中的 Volatile 关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存。

被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用 Volatile 来保证多线程操作时变量的可见性。

除了 Volatile，Java 中的 Synchronized 和 Final 两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。

### 有序性

在 Java 中，可以使用 Synchronized 和 Volatile 来保证多线程之间操作的有序性。

实现方式有所区别：Volatile 关键字会禁止指令重排。Synchronized 关键字保证同一时刻只允许一条线程操作。

好了，这里简单的介绍完了 Java 并发编程中解决原子性、可见性以及有序性可以使用的关键字。

读者可能发现了，好像 Synchronized 关键字是万能的，它可以同时满足以上三种特性，这也是很多人滥用 Synchronized 的原因。

但是 Synchronized 是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。


## 参考
- [1] JSR113
- [2] [终于有人把Java内存模型说清楚了](http://developer.51cto.com/art/201807/579744.htm)