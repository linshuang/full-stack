# synchronize同步


## CAS( Compare And Swap)<sup>[4]</sup>
In computer science, compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation.

在计算机科学里，cas是一个用于多线程中获得同步的原子指令。它使用一个给定值与特定内存位置的内容进行比较，当且仅当他们相同时，修改内存里的值为给定值。以上都是原子操作。

## semaphore 信号量<sup>[2]</sup>
信号量通过一个计数器控制对共享资源的访问，信号量的值是一个非负整数，所有通过它的线程都会将该整数减一。如果计数器大于0，则访问被允许，计数器减1；如果为0，则访问被禁止，所有试图通过它的线程都将处于等待状态。

计数器计算的结果是允许访问共享资源的通行证。因此，为了访问共享资源，线程必须从信号量得到通行证， 如果该信号量的计数大于0，则此线程获得一个通行证，这将导致信号量的计数递减，否则，此线程将阻塞直到获得一个通行证为止。当此线程不再需要访问共享资源时，它释放该通行证，这导致信号量的计数递增，如果另一个线程等待通行证，则那个线程将在那时获得通行证。

Semaphore可以被抽象为五个操作：

- 创建 Create
- 等待 Wait：
    ```
    线程等待信号量，如果值大于0，则获得，值减一；如果只等于0，则一直线程进入睡眠状态，知道信号量值大于0或者超时。
    ```
- 释放 Post
    ```
    执行释放信号量，则值加一；如果此时有正在等待的线程，则唤醒该线程。
    ```
- 试图等待 TryWait
    ```
    如果调用TryWait，线程并不真正的去获得信号量，还是检查信号量是否能够被获得，如果信号量值大于0，则TryWait返回成功；否则返回失败。
    ```
- 销毁 Destroy

## mutex 互斥量<sup>[2]</sup>
Mutex本质上说就是一把锁，提供对资源的独占访问，所以Mutex主要的作用是用于互斥。Mutex对象的值，只有0和1两个值。这两个值也分别代表了Mutex的两种状态。值为0, 表示锁定状态，当前对象被锁定，用户进程/线程如果试图Lock临界资源，则进入排队等待；值为1，表示空闲状态，当前对象为空闲，用户进程/线程可以Lock临界资源，之后Mutex值减1变为0。

Mutex可以被抽象为四个操作：
- 创建 Create
- 加锁 Lock
- 解锁 Unlock
- 销毁 Destroy

## 互斥量和信号量的区别<sup>[2]</sup>
1. 互斥量用于线程的互斥，信号量用于线程的同步。
```
这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。

互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
```
2. 互斥量值只能为0/1，信号量值可以为非负整数。
```
也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。
```
3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

## lock 锁

### 互斥锁
例如java语言中的synchronize关键字。

### 自旋锁<sup>[1]</sup>
自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

设计思路：
- while循环

自旋锁存在的问题
- 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。

自旋锁的优点
- 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快
- 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）

### 可重入锁
可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。

设计思路：
- 需要额外的计数用以记录锁被某一线程获取的次数，
- cas性质的current_thread用以记录当前已经获得锁的线程。

注：java语言中ReentrantLock和synchronized都是可重入锁，Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的。
### 读写锁
读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。

待补充！！！

### 公平锁

**公平锁**
> 加锁前先查看是否有排队等待的线程，有的话优先处理排在前面的线程，先来先得。

**非公平锁**
> 线程加锁时直接尝试获取锁，获取不到就自动等待。

非公平锁比公平锁性能高5-10倍，因为公平锁需要在多核情况下维护一个队列，如果当前线程不是队列的第一个无法获取锁，增加了线程切换次数。

### 可中断锁
待补充！！！

### 乐观锁和悲观锁
**悲观锁**：假设一定会发生并发冲突，通过阻塞其他所有线程来保证数据的完整性。例如，Synchronized多线程同步，具有排他性。

**乐观锁**：假设不会发生并发冲突，直接不加锁去完成某项更新，如果冲突就返回失败。例如，CAS机制，简单来说会有三个操作数，当前内存变量值V，变量预期值A，即将更新值B，当需要更新变量的时候，会直接将变量值V和预期值A进行比较，如果相同，则直接更新为B；如果不相同，则当前变量值V刷新到预期值中，然后重新尝试比较更新

乐观锁：适用于数据争用不严重/重试代价不大/需要相应速度快的场景。
悲观锁：适用于数据争用严重/重试代价大的场景。

## 参考
- [1] [深入理解自旋锁](https://blog.csdn.net/qq_34337272/article/details/81252853)
- [2] [线程同步-互斥锁与信号量的作用与区别](https://www.cnblogs.com/alinh/p/6905221.html)
- [3] [可重入锁和不可重入锁](https://www.cnblogs.com/dj3839/p/6580765.html)
- [4] [CAS](https://en.wikipedia.org/wiki/Compare-and-swap)